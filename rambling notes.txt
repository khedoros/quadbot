So, we've got a pretty easy starting point. 3 dimentsions of leg movement: the distance out from the body, the forward-back position, and the height of the body. From above, the robot itself uses polar coordinates. In the plane of a single leg's "elbow" and "wrist", we treat the leg itself like some vectors. So from the center of the robot, we might have x,y,z cartesian coords. The height gets used directly for the height of the "hip", Gotta have a separate number for the height of the finger/toe/tip (0, except in the case of a lifted leg).

So...we might decide that there's a "metronome", or a measure-counter. 4 steps to a stride, and maybe a minimum of 3 segments to each step (up+forward, forward, down+forward). So, 12 segments in a stride. Each leg is up for 3 of them, down for 9, but moving the whole time anyhow, so that the body maintains a smooth, forward motion. Max stride length will vary based on how far out from the body the legs are placed, but the full stride will *need* to be divided into 12-ish equal segments. That might be enough that the difference between radial distance and linear distance is negligible. If not, I'll have to do some more complicated calculations...or maybe just smaller timeslices. I'm kind of worried about how that would affect the movement speed though. It comes down to a limb moving forward by a full stride length during its step period, then sliding 1/3 of that backwards while each subsequent leg moves.

Program starts. Init legs into a neutral position (pointing out from the corners, half of the max distance, maybe with the body fairly low). Start reading some form of input. Like from an analog stick, take a direction (speed+angle). That turns into a vector that I can scale according to the longest possible stride in the direction. Shorter vector, shorter stride, I guess. Or maybe, shorter vector, more steps in the stride to slow it down. Experimentation necessary :-) I'm thinking of the vector as a pair of parallel rays, both starting from the same center point. The span that they cover together represents the cartesian movement of a limb tip over the course of a stride.

Deciding which leg to move: Check all 4 step states. Given current movement vector, decide how far each leg is from its optimal location. Pick the state that's the closest match to the current leg positions. If the best score is still pretty bad, might need to consider stepping each leg to the correct state 1 at a time, and continue from there. Or maybe we can smoothly correct...Experiment! The purpose of this ranking selection is to handle the cases where the driver suddenly switches direction, or something.

I think I'll need a function that takes a leg and a desired location to put it, and returns the closest it can get to that location. I also think that the "desired location" determining function might need to know about movement constraints of each leg, so that it doesn't pick somewhere immediately stupid.

I think....the central movement control will know the height of the robot and the height of each toe. It'll just send a 3-tuple to each leg for the (x,y,z) location of the toe in relation to the hip. I'll need a function that takes the bodyspace cartesian coords and generates legspace cartesian coords for each leg. The robot body itself will have a 0-degree direction (i.e. there will be a "forward"), but the legs won't know about it. Therefore, coordinate space conversion function.
